name: CI Pipeline

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main, develop ]

env:
  CARGO_TERM_COLOR: always
  RUST_BACKTRACE: 1

jobs:
  # Job 1: Code Quality Checks
  code-quality:
    name: Code Quality Checks
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        components: rustfmt, clippy
        
    - name: Cache Rust dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry/index
          ~/.cargo/registry/cache
          ~/.cargo/git/db
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
          
    - name: Check code formatting
      run: cargo fmt --all -- --check
      
    - name: Run Clippy lints
      run: cargo clippy --all-targets --all-features -- -D warnings
      
    - name: Check for security advisories
      run: |
        cargo install cargo-audit
        cargo audit

  # Job 2: Unit Tests
  unit-tests:
    name: Unit Tests
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      
    - name: Cache Rust dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry/index
          ~/.cargo/registry/cache
          ~/.cargo/git/db
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
          
    - name: Run unit tests
      run: cargo test --lib --bins
      
    - name: Generate test coverage report
      run: |
        cargo install cargo-tarpaulin
        cargo tarpaulin --out Xml --output-dir ./coverage
      continue-on-error: true
      
    - name: Upload coverage to Codecov
      uses: codecov/codecov-action@v4
      with:
        file: ./coverage/cobertura.xml
        flags: unittests
        name: rust-simple-api-coverage
      continue-on-error: true

  # Job 3: Build Check
  build-check:
    name: Build Check
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      
    - name: Cache Rust dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry/index
          ~/.cargo/registry/cache
          ~/.cargo/git/db
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
          
    - name: Build in release mode
      run: cargo build --release --verbose
      
    - name: Check binary size
      run: |
        ls -lh target/release/rust-simple-api
        size=$(stat -c%s target/release/rust-simple-api)
        echo "Binary size: $size bytes"
        # Alert if binary is larger than 50MB
        if [ $size -gt 52428800 ]; then
          echo "::warning::Binary size is larger than 50MB"
        fi

  # Job 4: Integration Tests with MongoDB
  integration-tests:
    name: Integration Tests
    runs-on: ubuntu-latest
    
    services:
      mongodb:
        image: mongo:7.0
        env:
          MONGO_INITDB_ROOT_USERNAME: admin
          MONGO_INITDB_ROOT_PASSWORD: password
          MONGO_INITDB_DATABASE: simple_api_db
        ports:
          - 27017:27017
        options: >-
          --health-cmd "mongosh --eval 'db.runCommand({ping: 1})'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5
        volumes:
          - ${{ github.workspace }}/mongo-init.js:/docker-entrypoint-initdb.d/mongo-init.js:ro
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      
    - name: Cache Rust dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry/index
          ~/.cargo/registry/cache
          ~/.cargo/git/db
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
          
    - name: Install MongoDB client tools and jq
      run: |
        sudo apt-get update
        sudo apt-get install -y mongodb-mongosh jq
        
    - name: Wait for MongoDB to be ready
      run: |
        echo "Waiting for MongoDB to be ready..."
        MAX_RETRIES=30
        RETRY_INTERVAL=2
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "Attempt $i/$MAX_RETRIES: Checking MongoDB readiness..."
          
          # Check MongoDB service health
          if mongosh --eval "db.adminCommand('ping')" mongodb://admin:password@localhost:27017/admin --quiet 2>/dev/null; then
            echo "âœ… MongoDB is ready!"
            
            # Additional verification - test database operations
            if mongosh --eval "
              db = db.getSiblingDB('simple_api_db');
              db.auth('api_user', 'api_password');
              db.test_collection.insertOne({test: 'readiness_check'});
              db.test_collection.drop();
            " mongodb://admin:password@localhost:27017/admin --quiet 2>/dev/null; then
              echo "âœ… MongoDB database operations verified successfully!"
            else
              echo "âš ï¸ MongoDB is responding but database operations failed"
            fi
            break
          else
            echo "âŒ MongoDB not ready yet..."
            
            # Show container logs for debugging if this is a later retry
            if [ $i -gt 15 ]; then
              echo "=== MongoDB Container Logs (last 20 lines) ==="
              docker logs --tail 20 ${{ job.services.mongodb.id }} || echo "Could not fetch MongoDB logs"
              echo "================================================"
            fi
          fi
          
          if [ $i -eq $MAX_RETRIES ]; then
            echo "âŒ MongoDB failed to become ready within $((MAX_RETRIES * RETRY_INTERVAL)) seconds"
            echo "=== Final MongoDB Container Logs ==="
            docker logs ${{ job.services.mongodb.id }} || echo "Could not fetch MongoDB logs"
            echo "===================================="
            exit 1
          fi
          
          sleep $RETRY_INTERVAL
        done
        
    - name: Verify MongoDB setup
      run: |
        echo "ðŸ” Verifying MongoDB setup..."
        
        # Test connection with application user
        echo "Testing application user permissions and database operations..."
        if mongosh --eval "
          try {
            db = db.getSiblingDB('simple_api_db');
            db.auth('api_user', 'api_password');
            
            // Test collection creation
            db.createCollection('test_connection');
            print('âœ… Collection creation successful');
            
            // Test document insertion
            db.test_connection.insertOne({
              test: 'connection',
              timestamp: new Date(),
              test_id: Math.random().toString(36).substring(7)
            });
            print('âœ… Document insertion successful');
            
            // Test document retrieval
            var docs = db.test_connection.find().toArray();
            print('âœ… Document retrieval successful, found ' + docs.length + ' documents');
            
            // Test document deletion
            db.test_connection.drop();
            print('âœ… Collection cleanup successful');
            
            print('ðŸŽ‰ All MongoDB operations completed successfully!');
          } catch (error) {
            print('âŒ MongoDB operation failed: ' + error);
            quit(1);
          }
        " mongodb://admin:password@localhost:27017/admin --quiet; then
          echo "âœ… MongoDB setup verification successful"
        else
          echo "âŒ MongoDB setup verification failed"
          echo ""
          echo "=== MongoDB Container Logs ==="
          docker logs ${{ job.services.mongodb.id }} || echo "Could not fetch MongoDB logs"
          echo "=============================="
          echo ""
          echo "=== MongoDB Container Status ==="
          docker ps -a --filter "id=${{ job.services.mongodb.id }}" || echo "Could not fetch container status"
          echo "=============================="
          echo ""
          echo "=== Network Information ==="
          docker network ls || echo "Could not list networks"
          echo "========================="
          exit 1
        fi
        
    - name: Create test environment file
      run: |
        cat > .env << EOF
        # MongoDB Configuration
        MONGODB_URI=mongodb://api_user:api_password@localhost:27017/simple_api_db
        DATABASE_NAME=simple_api_db
        
        # Server Configuration
        PORT=3030
        
        # Test Configuration
        TEST_API_BASE_URL=http://localhost:3030
        TEST_TIMEOUT_SECONDS=60
        EOF
        
    - name: Build application
      run: cargo build --verbose
      
    - name: Start application in background
      run: |
        echo "ðŸš€ Starting application in background..."
        cargo run > app.log 2>&1 &
        APP_PID=$!
        echo "âœ… Application started with PID: $APP_PID"
        echo "APP_PID=$APP_PID" >> $GITHUB_ENV
        
        # Create an enhanced health check script
        cat > check_app.sh << 'EOF'
        #!/bin/bash
        MAX_RETRIES=30
        RETRY_INTERVAL=2
        
        echo "ðŸ” Checking application health..."
        
        for i in $(seq 1 $MAX_RETRIES); do
          echo "Attempt $i/$MAX_RETRIES: Checking application health..."
          
          # Check if process is still running
          if ! kill -0 $APP_PID 2>/dev/null; then
            echo "âŒ Application process (PID: $APP_PID) is not running"
            echo "=== Application Logs ==="
            cat app.log
            echo "======================"
            exit 1
          fi
          
          # Check HTTP health endpoint
          if curl -f -s -m 5 http://localhost:3030/health > /dev/null 2>&1; then
            echo "âœ… Application is ready and responding!"
            
            # Additional health check - verify response content
            HEALTH_RESPONSE=$(curl -s http://localhost:3030/health 2>/dev/null || echo "")
            if echo "$HEALTH_RESPONSE" | grep -q '"status".*"ok"'; then
              echo "âœ… Application health check passed!"
              exit 0
            else
              echo "âš ï¸ Application responded but health check failed"
              echo "Response: $HEALTH_RESPONSE"
            fi
          else
            echo "âŒ Application not responding yet..."
          fi
          
          if [ $i -eq $MAX_RETRIES ]; then
            echo "âŒ Application failed to start within $((MAX_RETRIES * RETRY_INTERVAL)) seconds"
            echo "=== Application Startup Logs ==="
            cat app.log
            echo "=============================="
            echo "=== Process Status ==="
            ps aux | grep $APP_PID || echo "Process not found"
            echo "===================="
            echo "=== Network Status ==="
            netstat -tlnp 2>/dev/null | grep :3030 || echo "Port 3030 not listening"
            echo "====================="
            exit 1
          fi
          
          sleep $RETRY_INTERVAL
        done
        EOF
        chmod +x check_app.sh
        
    - name: Wait for application to be ready
      run: |
        echo "â³ Waiting for application to be ready..."
        ./check_app.sh
        
    - name: Show application logs if failed
      if: failure()
      run: |
        echo "âŒ Application startup failed. Showing logs:"
        echo "=== Application Logs ==="
        cat app.log || echo "No application logs found"
        echo "======================"
        echo "=== Environment Variables ==="
        env | grep -E "(MONGODB|DATABASE|PORT)" || echo "No relevant env vars found"
        echo "============================"
        
    - name: Verify application health
      run: |
        response=$(curl -s http://localhost:3030/health)
        echo "Health check response: $response"
        echo "$response" | jq -e '.status == "ok"'
        
    - name: Run integration tests
      run: cargo test --test integration_tests --verbose
      env:
        MONGODB_URI: mongodb://api_user:api_password@localhost:27017/simple_api_db
        DATABASE_NAME: simple_api_db
        TEST_API_BASE_URL: http://localhost:3030
        TEST_TIMEOUT_SECONDS: 60
        
    - name: Stop application
      if: always()
      run: |
        if [ -n "$APP_PID" ]; then
          echo "Stopping application with PID: $APP_PID"
          kill $APP_PID || true
          sleep 5
          kill -9 $APP_PID 2>/dev/null || true
          wait $APP_PID 2>/dev/null || true
        fi
        
    - name: Collect application logs
      if: failure()
      run: |
        echo "ðŸ” Collecting diagnostic information..."
        echo ""
        echo "=== Application Logs ==="
        cat app.log || echo "No application logs found"
        echo "======================"
        echo ""
        echo "=== MongoDB Container Logs ==="
        docker logs ${{ job.services.mongodb.id }} || echo "No MongoDB logs available"
        echo "=============================="
        echo ""
        echo "=== Container Status ==="
        docker ps -a --filter "name=mongodb" || echo "Could not fetch container status"
        echo "======================="
        echo ""
        echo "=== Resource Usage ==="
        echo "Memory usage:"
        free -h || echo "Could not fetch memory info"
        echo "Disk usage:"
        df -h || echo "Could not fetch disk info"
        echo "==================="
        echo ""
        echo "=== Network Status ==="
        echo "Listening ports:"
        netstat -tlnp 2>/dev/null | grep -E "(3030|27017)" || echo "Could not fetch port info"
        echo "==================="
        echo ""
        echo "=== Environment Variables ==="
        env | grep -E "(MONGODB|DATABASE|PORT|APP)" | sort || echo "No relevant env vars found"
        echo "============================="

  # Job 5: Security and Performance Checks (Optional but recommended)
  security-performance:
    name: Security & Performance Checks
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests, build-check, integration-tests]
    if: github.event_name == 'pull_request'
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      
    - name: Cache Rust dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry/index
          ~/.cargo/registry/cache
          ~/.cargo/git/db
          target
        key: ${{ runner.os }}-cargo-${{ hashFiles('Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-cargo-
          
    - name: Install cargo-deny for dependency checking
      run: cargo install cargo-deny
      
    - name: Check dependencies for vulnerabilities
      run: cargo deny check
      
    - name: Install cargo-bloat for binary analysis
      run: cargo install cargo-bloat
      
    - name: Analyze binary size
      run: |
        cargo build --release
        cargo bloat --release --crates
      continue-on-error: true

  # Job 6: Build Artifacts
  build-artifacts:
    name: Build Release Artifacts
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests, build-check, integration-tests]
    if: github.ref == 'refs/heads/main' && github.event_name == 'push'
    
    strategy:
      matrix:
        target: [x86_64-unknown-linux-gnu, x86_64-apple-darwin, x86_64-pc-windows-gnu]
        
    steps:
    - name: Checkout code
      uses: actions/checkout@v4
      
    - name: Install Rust toolchain
      uses: dtolnay/rust-toolchain@stable
      with:
        targets: ${{ matrix.target }}
        
    - name: Cache Rust dependencies
      uses: actions/cache@v4
      with:
        path: |
          ~/.cargo/registry/index
          ~/.cargo/registry/cache
          ~/.cargo/git/db
          target
        key: ${{ runner.os }}-${{ matrix.target }}-cargo-${{ hashFiles('Cargo.lock') }}
        restore-keys: |
          ${{ runner.os }}-${{ matrix.target }}-cargo-
          
    - name: Build for target
      run: cargo build --release --target ${{ matrix.target }}
      
    - name: Upload build artifacts
      uses: actions/upload-artifact@v4
      with:
        name: rust-simple-api-${{ matrix.target }}
        path: |
          target/${{ matrix.target }}/release/rust-simple-api
          target/${{ matrix.target }}/release/rust-simple-api.exe
        retention-days: 30

# Workflow status summary
  workflow-summary:
    name: Workflow Summary
    runs-on: ubuntu-latest
    needs: [code-quality, unit-tests, build-check, integration-tests]
    if: always()
    
    steps:
    - name: Summary
      run: |
        echo "## CI Pipeline Summary" >> $GITHUB_STEP_SUMMARY
        echo "| Job | Status |" >> $GITHUB_STEP_SUMMARY
        echo "|-----|--------|" >> $GITHUB_STEP_SUMMARY
        echo "| Code Quality | ${{ needs.code-quality.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Unit Tests | ${{ needs.unit-tests.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Build Check | ${{ needs.build-check.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "| Integration Tests | ${{ needs.integration-tests.result }} |" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "Overall pipeline status: ${{ job.status }}" >> $GITHUB_STEP_SUMMARY